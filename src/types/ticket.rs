//! Ticket types: TicketStage, TicketEvent, AdvisoryTicket, VerificationStatus,
//! legacy aliases, and related types

use serde::{Deserialize, Serialize};

use super::{
    AnomalyCategory, Campaign, DrillingMetrics, DrillingPhysicsReport, FinalSeverity,
    Operation, RigState, TicketSeverity, TicketType, WitsPacket,
};

// ============================================================================
// Ticket Context (Structured Routing - replaces tactical LLM)
// ============================================================================

/// Structured context attached to each advisory ticket.
///
/// Built by the tactical agent's deterministic pattern matcher. Provides the
/// strategic agent with precise, parseable information about which thresholds
/// were breached, replacing the previously planned tactical LLM description.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct TicketContext {
    /// Which specific thresholds were breached (ordered by severity)
    pub triggers: Vec<ThresholdBreach>,
    /// Detected pattern name (e.g. "Kick Warning", "Pack-off", "MSE Inefficiency")
    pub pattern: String,
    /// Rig state at time of ticket (Drilling, Tripping, etc.)
    pub rig_state: RigState,
    /// Current operation (Production, Milling, CementDrillOut, etc.)
    pub operation: Operation,
    /// Current campaign (Production or P&A)
    pub campaign: Campaign,
}

impl TicketContext {
    /// Format as structured text for the strategic LLM prompt
    pub fn to_prompt_section(&self) -> String {
        let mut s = format!("TICKET: {} ({})\n", self.pattern, self.triggers.first()
            .map(|t| t.threshold_type.as_str()).unwrap_or("INFO"));
        s.push_str("TRIGGERS:\n");
        for t in &self.triggers {
            s.push_str(&format!(
                "  - {}: {:.2} {} (threshold: {:.2} {}, {})\n",
                t.parameter, t.actual_value, t.unit, t.threshold_value, t.unit, t.threshold_type
            ));
        }
        s.push_str(&format!("RIG STATE: {:?}\n", self.rig_state));
        s.push_str(&format!("OPERATION: {:?}\n", self.operation));
        s.push_str(&format!("CAMPAIGN: {:?}\n", self.campaign));
        s
    }
}

/// A single threshold breach recorded by the tactical pattern matcher.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ThresholdBreach {
    /// Parameter name (e.g. "flow_balance", "torque_cv", "mse_efficiency")
    pub parameter: String,
    /// Measured value at time of detection
    pub actual_value: f64,
    /// Threshold that was breached
    pub threshold_value: f64,
    /// "WARNING" or "CRITICAL"
    pub threshold_type: String,
    /// Engineering unit (e.g. "gpm", "%", "ppg", "psi")
    pub unit: String,
}

// ============================================================================
// CfC Neural Network Types (serializable)
// ============================================================================

/// Serializable version of per-feature surprise from the CfC neural network.
/// The CfC internal `FeatureSurprise` uses `&'static str` for names, so this
/// owned variant is used on tickets and for JSON serialization.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct CfcFeatureSurpriseInfo {
    pub name: String,
    pub error: f64,
    pub magnitude: f64,
}

// ============================================================================
// Advisory Ticket System
// ============================================================================

/// Advisory ticket generated by tactical agent for strategic validation
///
/// This replaces direct alert generation - tactical agent creates tickets
/// that must be validated by the strategic agent using physics engine analysis.
///
/// The `trace_log` field implements the "Flight Recorder" pattern, tracking
/// every decision point in the ticket's lifecycle for debugging and auditing.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct AdvisoryTicket {
    /// Unix timestamp when the ticket was created
    pub timestamp: u64,
    /// Type of advisory (Optimization, RiskWarning, Intervention)
    pub ticket_type: TicketType,
    /// Category of the detected anomaly
    pub category: AnomalyCategory,
    /// Initial severity assessment from tactical agent
    pub severity: TicketSeverity,
    /// Current drilling metrics at time of detection
    pub current_metrics: DrillingMetrics,
    /// The parameter that triggered this ticket (e.g., "MSE", "flow_balance")
    pub trigger_parameter: String,
    /// The value of the trigger parameter
    pub trigger_value: f64,
    /// Threshold that was exceeded
    pub threshold_value: f64,
    /// Description of the detected issue
    pub description: String,
    /// Structured context from deterministic pattern matcher (replaces tactical LLM)
    #[serde(default)]
    pub context: Option<TicketContext>,
    /// Current depth at time of detection (ft)
    pub depth: f64,
    /// Flight Recorder trace log - tracks all decision points
    #[serde(default)]
    pub trace_log: Vec<TicketEvent>,
    /// CfC neural network anomaly score (0.0 = normal, 1.0 = highly anomalous)
    #[serde(default)]
    pub cfc_anomaly_score: Option<f64>,
    /// CfC per-feature surprise decomposition (top contributors to anomaly)
    #[serde(default, skip_serializing_if = "Vec::is_empty")]
    pub cfc_feature_surprises: Vec<CfcFeatureSurpriseInfo>,
    /// Causal leading indicators detected before this anomaly (Phase 5 causal inference)
    ///
    /// Parameters whose past values correlate most strongly with the current MSE spike,
    /// giving the driller advance warning of developing inefficiency.
    #[serde(default, skip_serializing_if = "Vec::is_empty")]
    pub causal_leads: Vec<CausalLead>,
    /// Active damping recommendation for stick-slip tickets (coordinator enrichment)
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub damping_recommendation: Option<super::DampingRecommendation>,
}

impl AdvisoryTicket {
    /// Add an event to the trace log
    pub fn log_event(&mut self, event: TicketEvent) {
        self.trace_log.push(event);
    }

    /// Add an info event to the trace log
    pub fn log_info(&mut self, stage: TicketStage, message: impl Into<String>) {
        self.trace_log.push(TicketEvent::info(stage, message));
    }

    /// Add a passed check event to the trace log
    pub fn log_passed(&mut self, stage: TicketStage, message: impl Into<String>) {
        self.trace_log.push(TicketEvent::passed(stage, message));
    }

    /// Add a failed check event to the trace log
    pub fn log_failed(&mut self, stage: TicketStage, message: impl Into<String>) {
        self.trace_log.push(TicketEvent::failed(stage, message));
    }

    /// Get a summary of the trace log for LLM context
    pub fn trace_summary(&self) -> String {
        if self.trace_log.is_empty() {
            return "No trace events recorded".to_string();
        }

        self.trace_log
            .iter()
            .map(|e| format!("[{}] {}", e.stage, e.message))
            .collect::<Vec<_>>()
            .join(" -> ")
    }

    /// Get only the passed/failed events for decision summary
    pub fn decision_summary(&self) -> String {
        let decisions: Vec<_> = self
            .trace_log
            .iter()
            .filter(|e| e.status == CheckStatus::Passed || e.status == CheckStatus::Failed)
            .map(|e| format!("{}: {}", e.stage, e.status))
            .collect();

        if decisions.is_empty() {
            "No decision events".to_string()
        } else {
            decisions.join(", ")
        }
    }
}

/// Verification status returned by strategic agent after physics validation
#[derive(Debug, Clone, Copy, Serialize, Deserialize, PartialEq, Eq)]
pub enum VerificationStatus {
    /// Advisory is awaiting strategic analysis
    Pending,
    /// Physics confirms the issue - generate dashboard advisory
    Confirmed,
    /// Physics rejects the issue (e.g., transient spike, returned to baseline)
    Rejected,
    /// Insufficient data or conflicting signals - monitor closely
    Uncertain,
}

impl std::fmt::Display for VerificationStatus {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            VerificationStatus::Pending => write!(f, "PENDING"),
            VerificationStatus::Confirmed => write!(f, "CONFIRMED"),
            VerificationStatus::Rejected => write!(f, "REJECTED"),
            VerificationStatus::Uncertain => write!(f, "UNCERTAIN"),
        }
    }
}

/// Result of strategic verification with detailed analysis
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct VerificationResult {
    /// The original advisory ticket being verified
    pub ticket: AdvisoryTicket,
    /// Verification status (Confirmed, Rejected, Uncertain)
    pub status: VerificationStatus,
    /// Physics report from strategic analysis
    pub physics_report: DrillingPhysicsReport,
    /// Reasoning for the verification decision
    pub reasoning: String,
    /// Final severity (only meaningful if Confirmed)
    pub final_severity: FinalSeverity,
    /// Whether to send advisory to dashboard
    pub send_to_dashboard: bool,
}

/// Enhanced physics report for strategic verification
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct EnhancedPhysicsReport {
    /// Base physics calculations
    pub base: DrillingPhysicsReport,
    /// Trend consistency from regression analysis (0.0 to 1.0)
    /// Higher values indicate consistent trend
    pub trend_consistency: f64,
    /// Confidence factor based on data quality and history depth
    pub confidence_factor: f64,
    /// Hours of history used for analysis
    pub history_hours: f64,
    /// Whether the anomaly is sustained (not transient)
    pub is_sustained: bool,
    /// Number of consecutive packets showing anomaly
    pub consecutive_anomaly_count: u32,
}

impl Default for EnhancedPhysicsReport {
    fn default() -> Self {
        Self {
            base: DrillingPhysicsReport::default(),
            trend_consistency: 0.0,
            confidence_factor: 0.0,
            history_hours: 0.0,
            is_sustained: false,
            consecutive_anomaly_count: 0,
        }
    }
}

/// Thresholds for verification decision logic
pub mod verification_thresholds {
    /// Minimum trend consistency for confirmation (0.0 to 1.0)
    pub const MIN_TREND_CONSISTENCY: f64 = 0.7;
    /// Minimum confidence factor for certain decisions
    pub const MIN_CONFIDENCE_FACTOR: f64 = 0.6;
    /// Minimum consecutive anomaly packets for sustained classification
    pub const MIN_CONSECUTIVE_FOR_SUSTAINED: u32 = 3;
    /// Minimum history required for verification (minutes)
    pub const MIN_HISTORY_MINUTES: f64 = 5.0;
}

// ============================================================================
// Causal Inference Types
// ============================================================================

/// A detected causal leading indicator for a drilling anomaly.
///
/// Represents a drilling parameter (e.g. WOB, RPM) whose historical values
/// precede an MSE spike at a specific lag, giving the driller advance warning
/// of developing inefficiency. Computed by the causal inference module using
/// cross-correlation over the 60-packet history buffer.
#[derive(Debug, Clone, Serialize, Deserialize, Default)]
pub struct CausalLead {
    /// Drilling parameter name (e.g. "WOB", "RPM", "Torque", "SPP", "ROP")
    pub parameter: String,
    /// Number of seconds this parameter leads the MSE response
    pub lag_seconds: u32,
    /// Pearson correlation coefficient between lagged parameter and MSE
    /// Positive = co-movement (parameter increase → MSE increase)
    /// Negative = inverse (parameter increase → MSE decrease)
    pub pearson_r: f64,
    /// Sign of the correlation: +1 when parameter and MSE move together,
    /// -1 when they move inversely. Use this to generate natural-language
    /// descriptions rather than interpreting it as a drilling prescription.
    pub correlation_sign: i8,
}

// ============================================================================
// Legacy Compatibility Types (for gradual migration)
// ============================================================================

/// Alias for backward compatibility during migration
pub type SensorPacket = WitsPacket;
/// Alias for backward compatibility during migration
pub type TacticalMetrics = DrillingMetrics;
/// Alias for backward compatibility during migration
pub type OperationalState = RigState;
/// Alias for backward compatibility during migration
pub type PhysicsReport = DrillingPhysicsReport;
/// Alias for backward compatibility during migration
pub type StrategicReport = super::StrategicAdvisory;
/// Alias for backward compatibility during migration
pub type VerificationTicket = AdvisoryTicket;


// ============================================================================
// Flight Recorder / Ticket Tracker System
// ============================================================================

/// Processing stage for advisory trace logging
#[derive(Debug, Clone, Copy, Serialize, Deserialize, PartialEq, Eq)]
pub enum TicketStage {
    /// Advisory ticket created by tactical agent
    TacticalCreation,
    /// Physics calculations in strategic agent
    StrategicPhysics,
    /// MSE trend analysis
    MseAnalysis,
    /// D-exponent/formation analysis
    FormationAnalysis,
    /// Flow balance / kick-loss check
    WellControlCheck,
    /// Hydraulics analysis
    HydraulicsCheck,
    /// Ensemble voting
    EnsembleVoting,
    /// LLM advisory generation
    LlmAdvisory,
    /// Final decision
    FinalDecision,
}

impl std::fmt::Display for TicketStage {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            TicketStage::TacticalCreation => write!(f, "TACTICAL"),
            TicketStage::StrategicPhysics => write!(f, "PHYSICS"),
            TicketStage::MseAnalysis => write!(f, "MSE"),
            TicketStage::FormationAnalysis => write!(f, "FORMATION"),
            TicketStage::WellControlCheck => write!(f, "WELL_CONTROL"),
            TicketStage::HydraulicsCheck => write!(f, "HYDRAULICS"),
            TicketStage::EnsembleVoting => write!(f, "VOTING"),
            TicketStage::LlmAdvisory => write!(f, "LLM"),
            TicketStage::FinalDecision => write!(f, "FINAL"),
        }
    }
}

/// Check status for advisory trace events
#[derive(Debug, Clone, Copy, Serialize, Deserialize, PartialEq, Eq)]
pub enum CheckStatus {
    /// Check passed (contributes to confirmation)
    Passed,
    /// Check failed (contributes to rejection)
    Failed,
    /// Check inconclusive (doesn't affect decision)
    Inconclusive,
    /// Informational event (no pass/fail)
    Info,
}

impl std::fmt::Display for CheckStatus {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            CheckStatus::Passed => write!(f, "PASSED"),
            CheckStatus::Failed => write!(f, "FAILED"),
            CheckStatus::Inconclusive => write!(f, "INCONCLUSIVE"),
            CheckStatus::Info => write!(f, "INFO"),
        }
    }
}

/// Individual event in the advisory trace log (Flight Recorder)
///
/// Each event records a decision point or check in the advisory pipeline.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct TicketEvent {
    /// Unix timestamp (milliseconds for high precision)
    pub timestamp_ms: u64,
    /// Processing stage where this event occurred
    pub stage: TicketStage,
    /// Status of this check (PASSED, FAILED, INCONCLUSIVE, INFO)
    pub status: CheckStatus,
    /// Human-readable message describing the event
    pub message: String,
}

impl TicketEvent {
    /// Create a new ticket event with current timestamp
    pub fn new(stage: TicketStage, status: CheckStatus, message: impl Into<String>) -> Self {
        use std::time::{SystemTime, UNIX_EPOCH};
        let timestamp_ms = SystemTime::now()
            .duration_since(UNIX_EPOCH)
            .map(|d| d.as_millis() as u64)
            .unwrap_or(0);
        Self {
            timestamp_ms,
            stage,
            status,
            message: message.into(),
        }
    }

    /// Create an info event (no pass/fail status)
    pub fn info(stage: TicketStage, message: impl Into<String>) -> Self {
        Self::new(stage, CheckStatus::Info, message)
    }

    /// Create a passed check event
    pub fn passed(stage: TicketStage, message: impl Into<String>) -> Self {
        Self::new(stage, CheckStatus::Passed, message)
    }

    /// Create a failed check event
    pub fn failed(stage: TicketStage, message: impl Into<String>) -> Self {
        Self::new(stage, CheckStatus::Failed, message)
    }

    /// Format as a single-line log entry
    pub fn to_log_line(&self) -> String {
        format!(
            "[{}] {} - {}: {}",
            self.timestamp_ms, self.stage, self.status, self.message
        )
    }
}
